#!/usr/bin/env node
// -*- mode: js -*-
// recover a manatee shard in error

var exec = require('child_process').exec;
var path = require('path');
var util = require('util');

var assert = require('assert-plus');
var bunyan = require('bunyan');
var getopt = require('posix-getopt');
var manatee = require('./manatee_common');
var pg = require('pg');
var vasync = require('vasync');
var verror = require('verror');
var zkplus = require('zkplus');

var LOG = bunyan.createLogger({
    name: path.basename(process.argv[1]),
    level: (process.env.LOG_LEVEL || 'info'),
    src: true,
    serializers: {
        err: bunyan.stdSerializers.err
    }
});

var parseOptions = function() {
    var option;
    var opts = {};
    var parser = new getopt.BasicParser('hv', process.argv);

    while((option = parser.getopt()) !== undefined) {
        switch (option.option) {
            case 'h':
                usage();
                break;
            case 'v':
                LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
                if (LOG.level() <= bunyan.DEBUG)
                    LOG = LOG.child({src: true});
                break;
            default:
                usage('invalid option: ' + option.option);
                process.exit(1);
                break;
        }
    }

    if (parser.optind() >= process.argv.length) {
        usage('missing required argument: "shard_id"');
    }

    if (parser.optind() + 1 >= process.argv.length) {
        usage('missing required argument: "my_ip"');
    }

    if (parser.optind() + 2 >= process.argv.length) {
        usage('missing required argument: "zookeeper_ip"');
    }

    opts.shardId = process.argv[parser.optind()];
    opts.myIp = process.argv[parser.optind() + 1];
    opts.zookeeperIp = process.argv[parser.optind() + 2];

    return opts;
};

var usage = function(msg) {
    if (msg) {
        console.error(msg);
    }

    var str = 'clears the manatee shard out of error state';
    str += '\nusage: ' + path.basename(process.argv[1]);
    str += ' shard_id my_ip zookeeper_ip';
    str += '\nexample: ./manatee_clear 1.moray.joyent.us 10.99.99.32 ' +
        '10.99.99.13';
    console.error(str);
    process.exit(msg ? 1 : 0);
};

var cleanupManatee = function(shardId, myIp, zookeeperIp, callback) {
    LOG.debug({
        shardId: shardId,
        myIp: myIp,
        zookeeperIp: zookeeperIp
    }, 'entering cleanupManatee');

    var tasks = [
        // look up in zookeeper to see who was the primary
        function createZkClient(arg, cb) {
            var zkLog = LOG.child({
                component: 'zookeeper'
            });
            manatee.createZkClient({log: zkLog, zk: zookeeperIp},
                function (err, zk)
                {
                    arg.zk = zk;
                    return cb(err);
                });
        },
        function isPrimary(arg, cb) {
            manatee.loadTopology(arg.zk, function (err, topology) {
                if (err) {
                    return cb(err);
                }

                arg.myShard = topology[shardId];
                LOG.debug({topology: topology}, 'got topology');
                if (!arg.myShard.error) {
                    return cb(new verror.VError(
                    'shard is not in error state'));
                }

                arg.isPrimary =
                (myIp === arg.myShard.error.primary);
                return cb();
            });

            return (undefined);
        },
        // if primary delete error node
        function deleteErrorNode(arg, cb) {
            if (!arg.isPrimary) {
                LOG.debug('not primary');
                return cb();
            }
            var path_ = '/manatee/' + shardId + '/error';
            LOG.info({
                path: path_
            }, 'removing error node');
            arg.zk.rmr(path_, cb);
            return (undefined);
        },
        // restart manatee
        function restartPrimarySitter(arg, cb) {
            if (!arg.isPrimary) {
                LOG.debug('not primary');
                return cb();
            }
            var cmd = 'svcadm disable manatee-sitter; ' +
                'svcadm enable manatee-sitter';
            LOG.info({cmd: cmd}, 'restarting manatee-sitter');

            exec(cmd, cb);
            return (undefined);
        },
        // if not primary, watch for error node to go away
        function watchErrorNode(arg, cb) {
            if (arg.isPrimary) {
                LOG.debug('not standby');
                return cb();
            }
            LOG.info('waiting for error node to be removed by ' +
            'primary');
        arg.zk.watch('/manatee/' + shardId + '/error',
            function(err, listener)
            {
                if (err) {
                    return cb(err);
                }
                listener.once('delete', function() {
                    LOG.info('error node deleted');
                    return cb();
                });
                return (undefined);
            });
            return (undefined);
        },
        // watch election, if there's a node under the path, then the
        // primary has started, so it's safe to restart standby
        function watchElection(arg, cb) {
            if (arg.isPrimary) {
                LOG.debug('not standby');
                return cb();
            }
            LOG.info('waiting for primary to come online');
            arg.zk.watch('/manatee/' + shardId + '/election',
                { method: 'list' }, function(err, listener) {

                    listener.on('children', function(children) {
                        LOG.info({
                            nodes: children
                        }, 'primary online');
                        return cb();
                    });
                });
                return (undefined);
        },
        // restart manatee
        function restartStdbySitter(arg, cb) {
            if (arg.isPrimary) {
                LOG.debug('not standby');
                return cb();
            }
            var cmd = 'svcadm disable manatee-sitter; ' +
                'svcadm enable manatee-sitter';
            LOG.info({cmd: cmd}, 'restarting manatee-sitter');
            exec(cmd, cb);
            return (undefined);
        }
    ];

    vasync.pipeline({funcs: tasks, arg: {}}, function(err) {
        LOG.debug({err: err}, 'finished cleanupManatee');
        return callback(err);
    });
};

var _opts = parseOptions();

cleanupManatee(_opts.shardId, _opts.myIp, _opts.zookeeperIp, function(err) {
    if (err) {
        LOG.fatal({err: err}, 'unable to cleanup manatee');
    }
    process.exit(err);
});
