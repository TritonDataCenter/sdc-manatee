#!/usr/bin/env node
// -*- mode: js -*-
// get the list of manatee transitions

var exec = require('child_process').exec;
var path = require('path');
var util = require('util');

var bunyan = require('bunyan');
var getopt = require('posix-getopt');
var manatee = require('./manatee_common');
var vasync = require('vasync');

var LOG = bunyan.createLogger({
    name: path.basename(process.argv[1]),
    level: (process.env.LOG_LEVEL || 'info'),
    src: true,
    serializers: {
        err: bunyan.stdSerializers.err
    }
});

var parseOptions = function() {
    var option;
    var opts = {};
    var parser = new getopt.BasicParser('hv', process.argv);

    while((option = parser.getopt()) !== undefined) {
        switch (option.option) {
            case 'h':
                usage();
                break;
            case 'v':
                LOG.level(Math.max(bunyan.TRACE, (LOG.level() - 10)));
                if (LOG.level() <= bunyan.DEBUG)
                    LOG = LOG.child({src: true});
                break;
            default:
                usage('invalid option: ' + option.option);
                process.exit(1);
                break;
        }
    }

    if (parser.optind() >= process.argv.length) {
        usage('missing required argument: "shard_id"');
    }

    if (parser.optind() + 1 >= process.argv.length) {
        usage('missing required argument: "zookeeper_ip"');
    }

    opts.shardId = process.argv[parser.optind()];
    opts.zookeeperIp = process.argv[parser.optind() + 1];

    return opts;
};

var usage = function(msg) {
    if (msg) {
        console.error(msg);
    }

    var binName = path.basename(process.argv[1]);
    var str = 'returns the shard transition history';
    str += '\nusage: ' + binName + ' shard_id zookeeper_ip';
    str += '\nexample: ' + binName + '1.moray.joyent.us 10.99.99.13';
    console.error(str);
    process.exit(msg ? 1 : 0);
};

var getHistory = function(shardId, zookeeperIp, callback) {
    LOG.debug({
        shardId: shardId,
        zookeeperIp: zookeeperIp
    }, 'manatee-history.getHistory: entering');

    var history;

    var tasks = [
        function createZkClient(arg, cb) {
            var zkLog = LOG.child({
                component: 'zookeeper'
            });
            manatee.createZkClient({log: zkLog, zk: zookeeperIp},
                function (err, zk)
                {
                    arg.zk = zk;
                    return cb(err);
                });
        },
        function listHistory(arg, cb) {
            var _path = '/manatee/' + shardId + '/history';
            LOG.debug({path: _path}, 'listing zk path');
            arg.zk.readdir(_path, function(err, nodes) {
                arg.nodes = nodes;
                LOG.debug({
                    err: err,
                    nodes: nodes
                }, 'returned from listHistory');
                return cb(err);
            });
        },
        // entry looks like timestamp-ip-role-master-slave-zkseq from zk.
        function formatNodes(arg, cb) {
            arg.formattedNodes = [];
            for (var i = 0; i < arg.nodes.length; i++) {
                var fNode = arg.nodes[i].split('-');
                arg.nodes[i] = {};
                var node = arg.nodes[i];
                for (var j = 0; j < fNode.length; j++) {
                    var entry = (fNode[j] === null ^ fNode[j] === 'undefined' ^
                                 fNode[j] === 'null') ?  "" : fNode[j];
                    switch (j) {
                        case 0:
                            node['time'] = entry;
                            node['date'] = new Date(parseInt(entry, 10));
                            break;
                        case 1:
                            node['ip'] = entry;
                            break;
                        case 2:
                            node['action'] = entry;
                            break;
                        case 3:
                            node['role'] = entry;
                            break;
                        case 4:
                            node['master'] = entry;
                            break;
                        case 5:
                            node['slave'] = entry;
                            break;
                        case 6:
                            node['zkSeq'] = entry;
                            break;
                        default:
                            break;
                    }
                }
            }

            return cb();
        },
        function sortNodes(arg, cb) {
            arg.nodes.sort(function(a, b) {
                return a.zkSeq - b.zkSeq;
            });

            history = arg.nodes;
            return cb();
        }
    ];

    vasync.pipeline({funcs: tasks, arg: {}}, function(err) {
        return callback(err, history);
    });
};

var _opts = parseOptions();

getHistory(_opts.shardId, _opts.zookeeperIp, function(err, history) {
    if (err) {
        console.log(err);
        LOG.fatal({err: err}, 'unable to get shard transition history.');
        process.exit(err);
    }

    for (var i = 0; i < history.length; i++) {
        console.log(JSON.stringify(history[i]));
    }
        //console.log(JSON.stringify(history));
    process.exit(0);
});
